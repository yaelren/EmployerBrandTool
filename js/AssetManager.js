/**
 * AssetManager.js - Manages local image assets for backgrounds and spots
 * Handles loading, caching, and providing images for shuffle operations
 */

class AssetManager {
    constructor() {
        this.backgroundImages = [];
        this.spotImages = [];
        this.imageCache = new Map();
        this.loadingPromises = new Map();
        
        // Supported image formats
        this.supportedFormats = ['jpg', 'jpeg', 'png', 'webp', 'gif'];
        
        // Asset paths
        this.backgroundPath = 'assets/backgrounds/';
        this.spotPath = 'assets/spots/';
    }
    
    /**
     * Initialize the asset manager and discover available images
     * @returns {Promise} Promise that resolves when initialization is complete
     */
    async initialize() {
        console.log('🖼️ Initializing Asset Manager...');
        
        try {
            // Try to discover images in the folders
            await this.discoverImages();
            
            // If no images found, create placeholders
            if (this.backgroundImages.length === 0 && this.spotImages.length === 0) {
                this.createPlaceholderInfo();
            }
            
            console.log(`✅ Asset Manager initialized: ${this.backgroundImages.length} backgrounds, ${this.spotImages.length} spot images`);
            
        } catch (error) {
            console.warn('⚠️ Asset discovery failed, using fallback mode:', error.message);
            this.createPlaceholderInfo();
        }
    }
    
    /**
     * Discover available images in the assets folders
     * @private
     */
    async discoverImages() {
        console.log('🔍 Discovering images in asset folders...');
        
        // Try multiple discovery methods
        const discoveryMethods = [
            () => this.discoverFromCompleteFileListing(),
            () => this.discoverFromManifest(),
            () => this.discoverFromDirectoryListing(),
            () => this.discoverByCommonPatterns()
        ];
        
        for (const method of discoveryMethods) {
            try {
                const result = await method();
                if (result && (this.backgroundImages.length > 0 || this.spotImages.length > 0)) {
                    console.log(`✅ Discovery successful using method: ${method.name}`);
                    return;
                }
            } catch (error) {
                console.log(`⚠️ Discovery method ${method.name} failed:`, error.message);
            }
        }
        
        console.log('🔍 All discovery methods exhausted, no images found');
    }
    
    /**
     * Try to discover images from complete file listing (generated by scan script)
     * @private
     */
    async discoverFromCompleteFileListing() {
        console.log('📋 Trying complete file listing discovery...');
        
        // Try the auto-generated complete file listing first
        try {
            const response = await fetch('assets/files.json');
            if (response.ok) {
                const listing = await response.json();
                
                if (listing.backgrounds && listing.spots) {
                    this.backgroundImages = listing.backgrounds.map(file => 
                        file.startsWith('assets/') ? file : `assets/${file}`
                    );
                    this.spotImages = listing.spots.map(file => 
                        file.startsWith('assets/') ? file : `assets/${file}`
                    );
                    
                    console.log(`📋 Found ${this.backgroundImages.length} backgrounds and ${this.spotImages.length} spots from complete listing`);
                    console.log('💡 Generated by running: npm run scan-assets');
                    return true;
                }
            }
        } catch (error) {
            // files.json doesn't exist or is invalid
        }
        
        return false;
    }
    
    /**
     * Try to discover images from manifest.json
     * @private
     */
    async discoverFromManifest() {
        console.log('📋 Trying manifest.json discovery...');
        const response = await fetch('assets/manifest.json');
        if (response.ok) {
            const manifest = await response.json();
            this.backgroundImages = manifest.backgrounds || [];
            this.spotImages = manifest.spots || [];
            console.log(`📋 Found ${this.backgroundImages.length} backgrounds and ${this.spotImages.length} spots from manifest`);
            return true;
        }
        return false;
    }
    
    /**
     * Try to discover images through directory listing endpoint
     * @private  
     */
    async discoverFromDirectoryListing() {
        console.log('📁 Trying directory listing discovery...');
        
        // Try common directory listing endpoints
        const endpoints = [
            'assets/list.json',        // Custom listing endpoint
            'assets/files.json',       // Alternative listing
            'assets/.index.json'       // Hidden index file
        ];
        
        for (const endpoint of endpoints) {
            try {
                const response = await fetch(endpoint);
                if (response.ok) {
                    const listing = await response.json();
                    
                    // Process different listing formats
                    if (listing.backgrounds && listing.spots) {
                        this.backgroundImages = listing.backgrounds;
                        this.spotImages = listing.spots;
                    } else if (listing.files) {
                        // Generic file list
                        this.categorizeFileList(listing.files);
                    }
                    
                    console.log(`📁 Found ${this.backgroundImages.length} backgrounds and ${this.spotImages.length} spots from ${endpoint}`);
                    return true;
                }
            } catch (error) {
                // Continue to next endpoint
            }
        }
        return false;
    }
    
    /**
     * Try to discover any image files in the folders
     * @private
     */
    async discoverByCommonPatterns() {
        console.log('🔍 Trying to discover all image files...');
        
        const extensions = ['jpg', 'jpeg', 'png', 'webp', 'gif', 'svg'];
        
        // Try common filename patterns without specific naming requirements
        // We'll try numbered files (1.jpg, 2.png, etc.) and some common generic names
        const commonNames = [
            '1', '2', '3', '4', '5', '6', '7', '8', '9', '10',
            '11', '12', '13', '14', '15', '16', '17', '18', '19', '20',
            'image', 'img', 'pic', 'photo', 'file', 'asset', 'item',
            'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'
        ];
        
        for (const name of commonNames) {
            for (const ext of extensions) {
                // Check backgrounds folder
                const bgPath = `${this.backgroundPath}${name}.${ext}`;
                if (await this.imageExists(bgPath)) {
                    this.backgroundImages.push(bgPath);
                    console.log(`✅ Found background: ${name}.${ext}`);
                }
                
                // Check spots folder  
                const spotPath = `${this.spotPath}${name}.${ext}`;
                if (await this.imageExists(spotPath)) {
                    this.spotImages.push(spotPath);
                    console.log(`✅ Found spot: ${name}.${ext}`);
                }
            }
            
            // Break early if we've found many images
            if (this.backgroundImages.length >= 20 && this.spotImages.length >= 20) {
                console.log('🎯 Found many images, stopping search');
                break;
            }
        }
        
        return this.backgroundImages.length > 0 || this.spotImages.length > 0;
    }
    
    
    /**
     * Categorize a generic file list into backgrounds and spots based on folder path
     * @param {string[]} files - Array of file paths
     * @private
     */
    categorizeFileList(files) {
        files.forEach(file => {
            const filename = file.toLowerCase();
            const isImage = this.supportedFormats.some(ext => filename.endsWith(`.${ext}`));
            
            if (!isImage) return;
            
            // Categorize based on folder path, not filename
            if (filename.includes('/background') || filename.includes('backgrounds/')) {
                this.backgroundImages.push(file);
                console.log(`✅ Found background from list: ${file}`);
            } else if (filename.includes('/spot') || filename.includes('spots/')) {
                this.spotImages.push(file);
                console.log(`✅ Found spot from list: ${file}`);
            } else {
                // If unclear, try to guess from context or put in both lists
                // For now, assume any other image could be either
                if (Math.random() > 0.5) {
                    this.backgroundImages.push(file);
                    console.log(`✅ Added to backgrounds: ${file}`);
                } else {
                    this.spotImages.push(file);
                    console.log(`✅ Added to spots: ${file}`);
                }
            }
        });
    }
    
    /**
     * Check if an image exists at the given path
     * @param {string} path - Image path to test
     * @returns {Promise<boolean>} True if image exists
     * @private
     */
    async imageExists(path) {
        try {
            const response = await fetch(path, { method: 'HEAD' });
            return response.ok;
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Load an image and cache it
     * @param {string} path - Path to the image
     * @returns {Promise<HTMLImageElement>} Loaded image element
     */
    async loadImage(path) {
        // Check cache first
        if (this.imageCache.has(path)) {
            return this.imageCache.get(path);
        }
        
        // Check if already loading
        if (this.loadingPromises.has(path)) {
            return this.loadingPromises.get(path);
        }
        
        // Start loading
        const loadPromise = new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous'; // For canvas compatibility
            
            img.onload = () => {
                this.imageCache.set(path, img);
                this.loadingPromises.delete(path);
                resolve(img);
            };
            
            img.onerror = () => {
                this.loadingPromises.delete(path);
                reject(new Error(`Failed to load image: ${path}`));
            };
            
            img.src = path;
        });
        
        this.loadingPromises.set(path, loadPromise);
        return loadPromise;
    }
    
    /**
     * Get a random background image
     * @returns {Promise<HTMLImageElement|null>} Random background image or null
     */
    async getRandomBackgroundImage() {
        if (this.backgroundImages.length === 0) {
            console.warn('⚠️ No background images available');
            return null;
        }
        
        const randomPath = this.backgroundImages[Math.floor(Math.random() * this.backgroundImages.length)];
        
        try {
            return await this.loadImage(randomPath);
        } catch (error) {
            console.warn(`⚠️ Failed to load background image: ${randomPath}`, error);
            return null;
        }
    }
    
    /**
     * Get a random spot image
     * @returns {Promise<HTMLImageElement|null>} Random spot image or null
     */
    async getRandomSpotImage() {
        if (this.spotImages.length === 0) {
            console.warn('⚠️ No spot images available');
            return null;
        }
        
        const randomPath = this.spotImages[Math.floor(Math.random() * this.spotImages.length)];
        
        try {
            return await this.loadImage(randomPath);
        } catch (error) {
            console.warn(`⚠️ Failed to load spot image: ${randomPath}`, error);
            return null;
        }
    }
    
    /**
     * Get all available background images
     * @returns {string[]} Array of background image paths
     */
    getBackgroundImagePaths() {
        return [...this.backgroundImages];
    }
    
    /**
     * Get all available spot images  
     * @returns {string[]} Array of spot image paths
     */
    getSpotImagePaths() {
        return [...this.spotImages];
    }
    
    /**
     * Add a background image programmatically
     * @param {string} path - Path to the image
     */
    addBackgroundImage(path) {
        if (!this.backgroundImages.includes(path)) {
            this.backgroundImages.push(path);
            console.log(`➕ Added background image: ${path}`);
        }
    }
    
    /**
     * Add a spot image programmatically
     * @param {string} path - Path to the image
     */
    addSpotImage(path) {
        if (!this.spotImages.includes(path)) {
            this.spotImages.push(path);
            console.log(`➕ Added spot image: ${path}`);
        }
    }
    
    /**
     * Create placeholder info when no images are found
     * @private
     */
    createPlaceholderInfo() {
        console.log(`
📁 No image files found in asset folders.

🎯 SUPER SIMPLE: Add images and scan!

STEP 1: Add ANY image files to these folders:
• assets/backgrounds/ - Any images you want as backgrounds  
• assets/spots/ - Any images you want for spots

STEP 2: Scan for ALL files (gets everything, any filename):
• Run: npm run scan-assets
• This finds ALL image files in the folders automatically
• No need to list filenames anywhere!

📝 ANY image filename works! The scan finds everything:
• vacation-photo.jpg, random-pic.png, logo.svg
• 1.jpg, 2.png, abc.gif, xyz.webp
• my-company-bg.jpg, whatever-icon.png

🔍 Discovery methods (in order):
1. 📁 Complete file scan (npm run scan-assets) - BEST METHOD
2. 📋 Manual manifest.json (if you want explicit control)  
3. 📁 Directory listing files (server integration)
4. 🔍 Common filename patterns (fallback)

🎲 For best results: Add images → Run 'npm run scan-assets' → Refresh page
For now, shuffling will use color backgrounds and empty spots.
        `);
    }
    
    /**
     * Generate a manifest.json file based on current images
     * @returns {Object} Manifest object
     */
    generateManifest() {
        return {
            backgrounds: this.backgroundImages,
            spots: this.spotImages,
            generated: new Date().toISOString(),
            description: "Auto-generated manifest for Employer Brand Tool assets"
        };
    }
    
    /**
     * Clear the image cache
     */
    clearCache() {
        this.imageCache.clear();
        this.loadingPromises.clear();
        console.log('🗑️ Image cache cleared');
    }
    
    /**
     * Get cache statistics
     * @returns {Object} Cache stats
     */
    getCacheStats() {
        return {
            cachedImages: this.imageCache.size,
            loadingImages: this.loadingPromises.size,
            backgroundImages: this.backgroundImages.length,
            spotImages: this.spotImages.length
        };
    }
}